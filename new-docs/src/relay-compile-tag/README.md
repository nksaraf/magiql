# Introduction

`relay-compiler` as a `graphql` tag.

- AST from the `graphql` parser -> transformed to best approximation of `relay-compiler` AST
- Used by `magiql` to enable `relay-runtime` (uptil now required the build-time setup of `relay-compiler` and `babel-relay-plugin`).
- Can still be used when types are generated by `relay-compiler` and you don't want a custom Babel config

## Differences

**Difference**:
Can't autodetect fragments across documents

**Solutions**:
Parser accepts the following syntax to include fragments (thanks to tagged template literals):

```tsx
const Pokemon_pokemon = graphql`
  fragment Pokemon_pokemon on Pokemon {
    id
    name
  }
`;

const PokemonsQuery = graphql`
  query PokemonsQuery {
    pokemons(first: 10) {
      id
      // fragment included in interpolation after ... is interpreted as fragment
      ...${Pokemon_pokemon}
    }
  }
`;
```

- Still have to import fragments _(Can attach fragments as properties of components but could simply just export them)_
- Still have to declare fragments outside components
- _Can transforming using regex find and replace. (Makes it easy to switch to the `relay-compiler`)_

**Difference:**
Can't detect which selection sets are lists

**Solutions:**
This can be easily worked out at runtime:

- Data in response would contain lists which can be detected while normalizing
- While reading from store, when a list of recordIDs is detected

**Difference:**
Can't generate types and include type hints

**Solutions:**

- Adds `__typename` to the GraphQL documents to fetch type information for the `relay-runtime`.
- Use `graphql-code-generator` for typescript types and global fragments _(adaptor coming soon...)_

_Might have missed more differences but these are the ones I notice._

## Motivation

_**Disclaimer:** This is NOT meant to discourage the use of `relay-compiler`, on the contrary, this is actually meant to be a gateway to it, encourage it. If you are considering using it, USE IT. The `magiql/cli` and `magiql/babel` exports are also installed when you install `magiql` which wrap the `relay-compiler`, `relay-config` and `babel-plugin-relay` packages into a preconfigured package designed for Typescript. They are designed to make it easy to switch to the compiler anytime._

**To use `relay-runtime` easily**.

Currently, it is necessary to use the `relay-compiler` which is an amazing piece of technology. (if you

- GraphQL Schema-aware development tooling
  - Typescript code-generation
  - Build-time validation of GraphQL Documentation
- GraphQL parsing is done at build time (gets skipped at runtime for better performance)
- Don't have to include `graphql` package in bundle
- Auto detects fragments without having to import them between files
- **Fragment-focused parsing which drives the relay-runtime**

There are also some interrupts on the way, which motivate this package

- GraphQL schema needed locally
- Strict rules for naming of GraphQL documents (can be seen as an advantage as well)
- Additional build-time step required for smaller projects
  - Difficult to use in CodeSandbox and similar environments
- Have to include Babel setup and customize it
- Can't use `relay-runtime` without it (`relay-runtime` is also amazing)

How it works:

- `relay-compiler` looks for `graphql` tags in your project
- produces typescript files for each fragment, query, etc. with parsed document and types
- parsed document follows the Relay AST structure (AST that `relay-runtime` understands)
- `babel-plugin-relay` replaces the `graphql` tag at build time to `require` statements pointing to the artifacts the `relay-compiler` generated,
  eg.

```typescript
const Pokemon_pokemon = graphql`
  fragment Pokemon_pokemon on Pokemon {
    id
    name
  }
`;

const Pokemon_pokemon = require("../__generated__/Pokemon_pokemon.graphql.ts");
```
