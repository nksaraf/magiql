# ðŸ§™ magiql

A simple but potentially magical GraphQL client for React. It stands on the shoulders of massive giants in the data-synchronization and state-management tools in this space both conceputally and some as actual dependencies.

* React-query
  * Data-fetching (network) layer
  * Stale-while-revalidate caching strategy
  * Request deduplication
  * Window Focus refetching
  * Network Status refetching
  * Infinite queries
  * Paginated queries
  * Parallel and dependent queries
  * Lazy queries
  * Polling/interval refetching
  * React Suspense support
  * Normalized caching (with the help of the relay compiler)
 
* Relay (compiler)
  * Build time optimizations (flatten fragments, add id fields, etc.)
  * Code-generation for types (for full typescript support)
  * Using fragments effectively with optimizations
  * Concept: `useFragment` hook (gamechanger!) to declaratively define data needs for components independent of the fetching of the data
  * Implementation: `relay-runtime` inspiration for (de)normalizating data
  * `magiql` allows us to use a `relay`-like hooks API without the server requirements or jumping to React Suspense (can't use the new relay hooks without that)
  
* Recoil
  * Normalized cache for data
  * Granular subscription (field-level) to data for fragments and queries based on exactly what they ask
  * **similar implementation for jotai is also being worked on**
  
* Urql
  * Concept: `exchange` API to customize execution of graphql request
  * Allowed easy ways to add logging, persisted queries, auth (with token refresh support)

Usage example:

```tsx
import {
  GraphQLClientProvider,
  GraphQLClient,
  useQuery,
  graphql,
} from "magiql";

const client = new GraphQLClient({
  endpoint: "https://graphql-pokemon.now.sh"
});

const SearchPokemon = () => {
  const { data, status, error } = useQuery(graphql`
    query pokemon($name: String) {
      pokemon(name: $name) {
        id
        number
        name
        attacks {
          special {
            name
            type
            damage
          }
        }

        image
      }
    }
  `, {
    variables: {
      name: "pikachu",
    },
  });

  return <pre>{JSON.stringify({ status, data, error }, null, 2)}</pre>;
};

const App = () => {
  return (
    <GraphQLClientProvider client={client}>
      <SearchPokemon />
    </GraphQLClientProvider>
  );
}

```

We can use middleware to customize options passed down to the fetch function. This allows adding functionality for things like auth.

```javascript
import { parseCookies } from "nookies";
import { createClient } from "magiql";

const getCookieToken = () => {
  return parseCookies().token;
};

export const authMiddleware = (getToken: () => string) => (fetch) => {
  return (url, operation, vars, options = {} as any) => {
    const token = getToken();
    options.headers = {
      ...options.headers,
      authorization: token ? `Bearer ${token}` : "",
    };
    const a = fetch(url, operation, vars, options);
    return a;
  };
};

const client = createClient("https://graphql-pokemon.now.sh", {}, [authMiddleware(getCookieToken)]);

```

## Magic

Inspired by [babel-blade](https://github.com/babel-blade/babel-blade), an experimental API to infer
the GraphQL query from usage within the components.

With babel config (example with Next.js):

```json
{
  "presets": ["next/babel"],
  "plugins": ["magiql/babel"]
}
```

Code example:

```tsx
import { useMagiqlQuery } from "magiql";

const MagicalPokemonSearch = () => {
  const { query, loading, error } = useMagiqlQuery("searchPokemon");
  
  if (loading) {
    return <div>loading...</div>;
  }

  const pokemons = query.pokemons({
      first: 10,
    })
    ?.map((pokemon) => ({ image: pokemon?.image, id: pokemon?.id, name: pokemon?.name }));

  return (
    <pre>
      {JSON.stringify({ loading, data: query, error, pokemons }, null, 2)}
    </pre>
  );
};
```

```graphql
# Query generated by magiql at build-time:

`query searchPokemon {
  pokemons_35d4: pokemons(first: 10) {
    image
    id
    name
  }
}`
```

